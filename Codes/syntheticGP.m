%% script to use the synthetic data generated by SE GP with hyperparameters
% of (1,1,0.1) in a 2D space. Then trajectories of these measurements are
% taken. Inference from these points is made. Finally, the location of some
% data points is perturbed to see how well GP can handle such wrong info. 

clear all
close all

%% Define the trajectories
% generate trajectories - imitate the sensor path
l = 20;
[selected_pts_nonRepeated, n_select, Trajectory, traj_select_Index] = trajGenerator(l);


%% generate the function value at Trajectory location based on a SE GP kernel
x_train = selected_pts_nonRepeated(:,2:3);
n_sample = size(x_train,1);
    
% mean function 
n_pts = size(selected_pts_nonRepeated,1);
m = zeros(n_pts,1);
theta = [1,1,0.1];
K = covMatrixSE(x_train,x_train,theta);
K_y = K + theta(3) * eye(n_pts);
K_inv = pinv(K_y);

% generate samples according to the distribution defined by GP - N(m,cov)
L = chol(K_y,'lower'); % Cholesky decomposition such that L * L' = cov
u = diag(normrnd(zeros(n_pts),eye(n_pts)));
y = m + L * u;
log_likelihood = -0.5*y.'* K_inv * y - 0.5*log(det(K_y)) - n_sample/0.5*log(2*pi);

% save the training data in trainingData.mat for later optimisation for
% theta
save('trainingData.mat','x_train','y')

%% plot to show the trajectories and measurements associated with each trajectory
figure(1)
scatter3(x_train(:,1),x_train(:,2),y)
title('Measurements along the selected trajectories (Synthetic data generated by a Squared Exp GP with hyperparameters of [1,1,0.1])')
xlabel('x')
ylabel('y')
zlabel('function value')
hold on
index_Plot = 1;
counter = 1;
for i = 1:n_select
    n_pts_on_traj = 0;
    while selected_pts_nonRepeated(counter) == traj_select_Index(i)
        counter = counter + 1;
        n_pts_on_traj = n_pts_on_traj + 1;
    end
    draw_Index = index_Plot:index_Plot+n_pts_on_traj-1;
    plot3(x_train(draw_Index,1),x_train(draw_Index,2),y(draw_Index));
    index_Plot = index_Plot + n_pts_on_traj;
 end
hold off

%% GPR on these measurements
% prediction input space locations
pred_grid = 0:0.5:20;
n_grid = length(pred_grid);
x_pred = zeros(n_grid^2,2);
for i = 1:n_grid
    x_pred((i-1)*n_grid+1:i*n_grid,1) = pred_grid.';
    x_pred((i-1)*n_grid+1:i*n_grid,2) = pred_grid(i)*ones(n_grid,1);
end
n_pred = n_grid^2;

% prediction cov matrices
K_star = covMatrixSE(x_train,x_pred,theta);
K_star2 = covMatrixSE(x_pred,x_pred,theta);

% make prediciton 
GPR_mean = K_star.' * K_inv * y;
GPR_cov = K_star2 - K_star.' * K_inv * K_star;

%% plot the 3d map
Z = reshape(GPR_mean,[n_grid,n_grid]);
figure(2)
mesh(pred_grid,pred_grid,Z.');
hold on
scatter3(x_train(:,1),x_train(:,2),y)
hold off

% %% Optimisation to find the hyperparameters of the GP model
% theta0 = [0.9999,0.99999,0.10001];
% fun = @logMarginalLikelihoodWithoutGradient;
% A = [];
% b = [];
% Aeq = [];
% beq = [];
% lb = [0,0,0];
% ub = [];
% nonlcon = [];
% options = optimoptions(@fmincon,'Display','iter','Algorithm','interior-point');
% [theta_test,fval,exitflag,output] = fmincon(fun,theta0,A,b,Aeq,beq,lb,ub,nonlcon,options);
% 
% % plot the prediction using the hyperparameters from the optimisation 
% % prediction cov matrices
% K_test_star = covMatrixSE(x_train,x_pred,theta_test);
% K_test_star2 = covMatrixSE(x_pred,x_pred,theta_test);
% 
% % make prediciton 
% GPR_test_mean = K_test_star.' * K_inv * y;
% GPR_test_cov = K_test_star2 - K_test_star.' * K_inv * K_test_star;
% 
% % plot the 3d map
% Z_test = reshape(GPR_test_mean,[n_grid,n_grid]);
% figure(3)
% mesh(pred_grid,pred_grid,Z_test.');
% hold on
% scatter3(x_train(:,1),x_train(:,2),y)
% hold off

%% use GPML to work a solution as a reference to compare with
% specify mean, covariance and likelihood functions
meanfunc = @meanZero;
covfunc = @covSEiso;
likfunc = @likGauss;

% initialise hyperparameter struct
hyp = struct('mean', [], 'cov', [log(0.9) log(0.9)], 'lik', log(0.1));

% call gp() function
[nlz dnlz] = gp(hyp, @infGaussLik, meanfunc, covfunc, likfunc, x_train, y);
hyp2 = minimize(hyp, @gp, -300, @infGaussLik, meanfunc, covfunc, likfunc, x_train, y);
[mu s2] = gp(hyp2, @infGaussLik, meanfunc, covfunc, likfunc, x_train, y, x_pred);

% figure(4)
% f = [mu+2*sqrt(s2); flipdim(mu-2*sqrt(s2),1)];
% fill([xs; flipdim(xs,1)], f, [7 7 7]/8)
% hold on; plot(xs, mu); plot(x, y, '+')
Z_gpml = reshape(mu,[n_grid,n_grid]);
figure(4)
mesh(pred_grid,pred_grid,Z_gpml.');
hold on
scatter3(x_train(:,1),x_train(:,2),y)
hold off